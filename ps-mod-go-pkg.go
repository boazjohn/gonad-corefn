package main

import (
	"fmt"
	"os"
	"path"

	"github.com/metaleap/go-util"
	"github.com/metaleap/go-util/dev/ps"
)

type modPkg struct { //	A PureScript Module transforms into a Go Package, hence modPkg
	reGenIr        bool
	qName          string //	eg	Control.Monad.Eff.Uncurried, My.Main etc
	lName          string //	eg	Uncurried, Main etc
	pName          string //	eg	Control_Monad_Eff_Uncurried, My_Main etc
	srcFilePath    string //	eg	bower_components/purescript-eff/src/Control/Monad/Eff/Uncurried.purs or src/My/Main.purs etc
	cfnFilePath    string //	eg	output/Control.Monad.Eff.Uncurried/corefn.json, output/My.Main/corefn.json etc
	impFilePath    string //	eg	output/Control.Monad.Eff.Uncurried/coreimp.json, output/My.Main/coreimp.json etc
	extFilePath    string //	eg	output/Control.Monad.Eff.Uncurried/externs.json, output/My.Main/externs.json etc
	irMetaFilePath string //	eg	output/Control.Monad.Eff.Uncurried/gonad.json, output/My.Main/gonad.json etc
	goOutDirPath   string //	eg	Control/Monad/Eff/Uncurried, My/Main etc
	goOutFilePath  string //	eg	Control/Monad/Eff/Uncurried/Uncurried.go, My/Main/Main.go etc

	irMeta        *irMeta
	irAst         *irAst
	parentPkg     *psPkg
	coreExt       *udevps.Extern
	coreImp       *udevps.CoreImp
	coreFn        *udevps.CoreFn
	gopkgfilepath string // full target file path (not necessarily absolute but starting with the given gopath)
}

func findModuleByQName(qname string) (modinfo *modPkg) {
	if qname != "" {
		if modinfo = Proj.moduleByQName(qname); modinfo == nil {
			for _, dep := range Deps {
				if modinfo = dep.moduleByQName(qname); modinfo != nil {
					return
				}
			}
		}
	}
	return
}

func findModuleByPName(pname string) (modinfo *modPkg) {
	if pname != "" {
		if modinfo = Proj.moduleByPName(pname); modinfo == nil {
			for _, dep := range Deps {
				if modinfo = dep.moduleByPName(pname); modinfo != nil {
					return
				}
			}
		}
	}
	return
}

func (me *modPkg) impPath() string {
	return path.Join(me.parentPkg.GoOut.PkgDirPath, me.goOutDirPath)
}

func (me *modPkg) loadPkgIrMeta() (err error) {
	if err = umisc.JsonDecodeFromFile(me.irMetaFilePath, &me.irMeta); err == nil {
		me.irMeta.mod = me
		me.irMeta.populateImportsEarly()
	}
	return
}

func (me *modPkg) populatePkgIrMeta() {
	if me.coreFn == nil {
		me.irMeta.populateFromLoaded()
	} else {
		me.coreFn.Prep()
		me.irMeta.populateFromCore()
	}
}

func (me *modPkg) reGenPkgIrMeta() (err error) {
	// if err = umisc.JsonDecodeFromFile(me.extFilePath, &me.coreExt); err == nil {
	// 	if err = umisc.JsonDecodeFromFile(me.impFilePath, &me.coreImp); err == nil {
	if err = umisc.JsonDecodeFromFile(me.cfnFilePath, &me.coreFn); err == nil {
		me.irMeta = &irMeta{mod: me}
		me.irMeta.populateImportsEarly()
		// } else {
		// 	me.coreImp = nil
	}
	// 	}
	// }
	return
}

func (me *modPkg) prepIrAst() {
	me.irAst = &irAst{mod: me, irM: me.irMeta}
	me.irAst.irABlock.root = me.irAst
	me.irAst.prepFromCore()
}

func (me *modPkg) reGenPkgIrAst() {
	me.irAst.finalizePostPrepOps()
}

func (me *modPkg) writeGoFile() (err error) {
	var f *os.File
	if f, err = os.Create(me.gopkgfilepath); err == nil {
		defer f.Close()
		if !Flag.NoPrefix {
			_, err = fmt.Fprintf(f, "// Generated by gonad from: %s, generated from: %s\n", me.cfnFilePath, me.srcFilePath)
		}
		if err == nil {
			err = me.irAst.writeAsGoTo(f)
		}
	}
	return
}

func (me *modPkg) writeIrAstFile() (err error) {
	var f *os.File
	if f, err = os.Create(me.irMetaFilePath[:len(me.irMetaFilePath)-len(".json")] + ".ast.json"); err == nil {
		defer f.Close()
		me.irAst.writeAsJsonTo(f)
	}
	return
}

func (me *modPkg) writeIrMetaFile() (err error) {
	var f *os.File
	if f, err = os.Create(me.irMetaFilePath); err == nil {
		defer f.Close()
		err = me.irMeta.writeAsJsonTo(f)
	}
	return
}
